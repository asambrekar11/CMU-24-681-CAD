set(TARGET_NAME "ysfontrenderer")
set(IS_LIBRARY_PROJECT 1)
set(LIB_DEPENDENCY ysclass ysbitmap ysbitmapfont)
set(INCLUDE_DEPENDENCY ysclass ysbitmap ysbitmapfont yssystemfont)
set(OWN_HEADER_PATH .)
set(SINGLE_TARGET 1)
set(SUB_FOLDER "")
set(REALLY_NEED_CPP11 0)    # Setting 1 will enable use of C++11 libraries, but lose compatibility with OSX 10.6.



# yssystemfont must be excluded from the LIB_DEPENDENCY since some command-line programs link ysnullsystemfont instead of yssystemfont.



#YSBEGIN "CMake Header" Ver 20150201
# YS CMakeLists Template
# Copyright (c) 2015 Soji Yamakawa.  All rights reserved.
# http://www.ysflight.com
# 
# Redistribution and use in source and binary forms, with or without modification, 
# are permitted provided that the following conditions are met:
# 
# 1. Redistributions of source code must retain the above copyright notice, 
#    this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice, 
#    this list of conditions and the following disclaimer in the documentation 
#    and/or other materials provided with the distribution.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" 
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, 
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
# PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS 
# BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR 
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE 
# GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT 
# OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

cmake_minimum_required(VERSION 3.0.0)
if("${CMAKE_BINARY_DIR}" MATCHES "^${CMAKE_SOURCE_DIR}")
	message(FATAL_ERROR "In-source build prohibited.\nClear cache and Start cmake from somewhere else.")
endif()

set(ALL_DEPENDENCY ${INCLUDE_DEPENDENCY} ${LIB_DEPENDENCY})
list(LENGTH ALL_DEPENDENCY ALL_DEPENDENCY_LENGTH)
if(${ALL_DEPENDENCY_LENGTH} GREATER 0)
	list(REMOVE_DUPLICATES ALL_DEPENDENCY)
endif()

if(MSVC)
	if(NOT WIN_SUBSYSTEM)
		set(WIN_SUBSYSTEM CONSOLE)
	endif()

	if(CMAKE_SIZEOF_VOID_P EQUAL 8)
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:${WIN_SUBSYSTEM},5.02 /MACHINE:x64")
	else()
		set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:${WIN_SUBSYSTEM},5.01 /MACHINE:X86")
	endif()
endif()

if(NOT APPLE AND "${EXE_TYPE}" STREQUAL "MACOSX_BUNDLE")
	set(EXE_TYPE)
endif()

if(NOT DEFINED TARGET_NAME)
	message(FATAL_ERROR "TARGET_NAME not defined.")
endif()
if(NOT DEFINED IS_LIBRARY_PROJECT)
	message(FATAL_ERROR "IS_LIBRARY_PROJECT not defined.")
endif()
if(NOT DEFINED SINGLE_TARGET)
	message(FATAL_ERROR "SINGLE_TARGET not defined.")
endif()

if(MSVC)
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /MP /MT /wd4996")
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /MP /MT /wd4996")
	string(REGEX REPLACE "/MD" "/MT" CMAKE_CXX_FLAGS_RELEASE ${CMAKE_CXX_FLAGS_RELEASE})
	string(REGEX REPLACE "/MD" "/MT" CMAKE_C_FLAGS_RELEASE ${CMAKE_C_FLAGS_RELEASE})
	string(REGEX REPLACE "/MDd" "/MTd" CMAKE_CXX_FLAGS_DEBUG ${CMAKE_CXX_FLAGS_DEBUG})
	string(REGEX REPLACE "/MDd" "/MTd" CMAKE_C_FLAGS_DEBUG ${CMAKE_C_FLAGS_DEBUG})
elseif(APPLE)
	# 2015/07/15
	#   Sorry.  I pulled the plug.  All of my programs, including YS FLIGHT SIMULATOR, won't support 
	#   OSX 10.6 after today.  Apple deliberately disabled C++11 features in the libraries that I need to make my 
	#	programs compatible with OSX 10.6.
	#
	#	I know OSX 10.9 is evil for older models.  My 2008 MacBook Pro flies with OSX 10.6, but becoes
	#	a sloth with OSX 10.9.  Apple used to be a challenger pursuing Microsoft, but it is now an empire
	#	that Microsoft once was, and is doing everything that Microsoft did.  Apple inprison programmers
	#	with Apple-only programming language called Swift (already doing with Objective-C though) and Apple-only
	#	graphics toolkit called Metal, just as Microsoft did with C# and Direct3D.  Apple is making operating
	#	system heavier, slower, and inefficient, just as Microsoft has been doing.  The same thing is going all 
	#	around again.
	#
	#	OK, I warn you.  If you are investing your precious time for learning Swift and/or Metal, you are 
	#	taking a very big gamble.  Apple will throw it away when they get bored of it.  Learning one programming 
	#	language is not just understanding syntax.  You need to write considerable amount of code to learn the 
	#	best practices.  So far, C and C++ have been with for more than 20 years.  Will Swift live that long?
	#	Nobody knows.  I doubt it.  Swift is developed by a closed group.  Maybe one genius is in charge now.
	#	But, when the genius leaves, it could cramble down.  C and C++ are developed by the top computer
	#	scientists of the world.  To me, which is superior is obvious.
	#
	#	No user wants a new operating system.  Everyone wants their system to be cleaner, more stable, more 
	#	secure, and more resource-efficient.  Neither Apple nor Microsoft gets it.  We continue to be forced
	#	to throw away perfectly healthy hardware, and buy new over-spec hardware, which is inefficiently
	#	operated by the wasteful operating systems.
	#
	#	Sad and outrageous.  But, that's what Apple do.  Apple takes C++11 hostage and forces programmers 
	#	to drop support for older but still active-duty operating systems.
	#
	#	Mac is a good computer though.  I am happy with my 2011 MacMini.  I probably would be happy with
	#	my 2008 MacBook Pro if I still can (practically) use it with OSX 10.6, or if 10.9 is as efficient 
	#	as 10.6.

	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -mmacosx-version-min=10.9")
	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -mmacosx-version-min=10.9")
else()
	set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++0x")
endif()

if(NOT DATA_COPY_DIR)
	if("${EXE_COPY_DIR}" STREQUAL "")
		if("${EXE_TYPE}" STREQUAL "MACOSX_BUNDLE")
			set(DATA_COPY_DIR "${EXECUTABLE_OUTPUT_PATH}/${TARGET_NAME}.app/Contents/Resources")
		elseif(MSVC)
			set(DATA_COPY_DIR "${EXECUTABLE_OUTPUT_PATH}/${CMAKE_BUILD_TYPE}")
		else()
			set(DATA_COPY_DIR "${EXECUTABLE_OUTPUT_PATH}")
		endif()
	else()
		if("${EXE_TYPE}" STREQUAL "MACOSX_BUNDLE")
			set(DATA_COPY_DIR "${EXE_COPY_DIR}/${TARGET_NAME}.app/Contents/Resources")
		else()
			set(DATA_COPY_DIR "${EXE_COPY_DIR}")
		endif()
	endif()
endif()

if(NOT ${IS_LIBRARY_PROJECT} EQUAL 0)
	#set(YS_LIBRARY_LIST ${YS_LIBRARY_LIST} ${TARGET_NAME} PARENT_SCOPE)
	# Modified as suggested in CMake performance tips.
	list(APPEND YS_LIBRARY_LIST ${TARGET_NAME})
	set(YS_LIBRARY_LIST ${YS_LIBRARY_LIST} PARENT_SCOPE)
endif()

#YSEND



if(MSVC)
	set(platform_SRCS "")
	set(platform_HEADERS "")
elseif(APPLE)
	set(platform_SRCS "")
	set(platform_HEADERS "")
elseif(UNIX)
	set(platform_SRCS "")
	set(platform_HEADERS "")
else()
	set(platform_SRCS "")
	set(platform_HEADERS "")
endif()



set(SRCS
${platform_SRCS}
ysfixedfontrenderer.cpp
ysfontrenderer.cpp
yssystemfontrenderer.cpp
)

set(HEADERS
${platform_HEADERS}
ysfixedfontrenderer.h
ysfontrenderer.h
yssystemfontrenderer.h
)



#YSBEGIN "CMake Footer" Ver 20150201
if(YS_CXX_FLAGS)
	foreach(SRC ${SRCS})
		if(${SRC} MATCHES .cpp$)
			set_source_files_properties(${CMAKE_CURRENT_SOURCE_DIR}/${SRC} PROPERTIES COMPILE_FLAGS "${YS_CXX_FLAGS}")
		endif()
	endforeach(SRC)
endif()

foreach(ONE_TARGET ${TARGET_NAME})
	message([${ONE_TARGET}])

	if(${SINGLE_TARGET} EQUAL 1)
		if(${IS_LIBRARY_PROJECT} EQUAL 0)
			add_executable(${ONE_TARGET} ${EXE_TYPE} ${SRCS} ${HEADERS})
		else()
			add_library(${ONE_TARGET} ${LIB_OPTION} ${SRCS} ${HEADERS})
		endif()
	endif()

	set(${ONE_TARGET}_SRC_DIR "${CMAKE_CURRENT_SOURCE_DIR}" PARENT_SCOPE)

	if(NOT ${IS_LIBRARY_PROJECT} EQUAL 1)
		if(NOT "${EXE_COPY_DIR}" STREQUAL "")
			# 2015/02/01 CMAKE_CONFIGURATION_TYPES may be empty.
			set_target_properties(${ONE_TARGET} PROPERTIES RUNTIME_OUTPUT_DIRECTORY "${EXE_COPY_DIR}")
			set_target_properties(${ONE_TARGET} PROPERTIES RUNTIME_OUTPUT_DIRECTORY_DEBUG "${EXE_COPY_DIR}")
			set_target_properties(${ONE_TARGET} PROPERTIES RUNTIME_OUTPUT_DIRECTORY_RELEASE "${EXE_COPY_DIR}")
			foreach(CFGTYPE ${CMAKE_CONFIGURATION_TYPES})
				string(TOUPPER ${CFGTYPE} UCFGTYPE)
				set_target_properties(${ONE_TARGET} PROPERTIES RUNTIME_OUTPUT_DIRECTORY_${UCFGTYPE} "${EXE_COPY_DIR}")
			endforeach(CFGTYPE)
		endif()
	endif()

	if(NOT ${IS_LIBRARY_PROJECT} EQUAL 0)
		set(INHERITING_INCLUDE_DIR "${CMAKE_CURRENT_SOURCE_DIR}" ${OWN_HEADER_PATH} ${ADDITIONAL_HEADER_PATH})

		foreach(INCLUDEHDR ${ALL_DEPENDENCY})
			foreach(ONE_INCOMING_INCLUDE_DIR ${${INCLUDEHDR}_INCLUDE_DIR})
				# set(INHERITING_INCLUDE_DIR ${INHERITING_INCLUDE_DIR} ${ONE_INCOMING_INCLUDE_DIR})
				# Modified as suggested in CMake performance tips.
				list(APPEND INHERITING_INCLUDE_DIR ${ONE_INCOMING_INCLUDE_DIR})
			endforeach(ONE_INCOMING_INCLUDE_DIR)
		endforeach(INCLUDEHDR)

		list(REMOVE_DUPLICATES INHERITING_INCLUDE_DIR)
		foreach(DIR ${INHERITING_INCLUDE_DIR})
			target_include_directories(${ONE_TARGET} PUBLIC ${DIR})
		endforeach(DIR)

		set(${ONE_TARGET}_INCLUDE_DIR "${INHERITING_INCLUDE_DIR}" PARENT_SCOPE)
		if("${VERBOSE_MODE}" EQUAL "1")
			message("Inheriting include directories ${INHERITING_INCLUDE_DIR}")
		endif()
	endif()

	if(NOT ${SUB_FOLDER} STREQUAL "")
		if("${VERBOSE_MODE}" EQUAL "1")
			message("Putting in folder ${SUB_FOLDER}")
		endif()
		set_property(TARGET ${ONE_TARGET} PROPERTY FOLDER ${SUB_FOLDER})
	endif()

	foreach(LINKLIB ${LIB_DEPENDENCY})
		if("${VERBOSE_MODE}" EQUAL "1")
			message(Lib=${LINKLIB})
		endif()
		target_link_libraries(${ONE_TARGET} ${LINKLIB})
	endforeach(LINKLIB)

	foreach(INCDIR ${ADDITIONAL_HEADER_PATH})
		if("${VERBOSE_MODE}" EQUAL "1")
			message(Additional Include=${INCDIR})
		endif()
		include_directories(${INCDIR})
	endforeach(INCDIR)

	message(".")
endforeach(ONE_TARGET)

if(DATA_FILE_LOCATION)
	foreach(ONE_DATA_FILE_LOCATION ${DATA_FILE_LOCATION})
		foreach(ONE_TARGET ${TARGET_NAME})
			if(MSVC)
				string(REGEX REPLACE "/" "\\\\" WIN_ONE_DATA_FILE_LOCATION "${ONE_DATA_FILE_LOCATION}")
				string(REGEX REPLACE "/" "\\\\" WIN_DATA_COPY_DIR "${DATA_COPY_DIR}")
				add_custom_command(TARGET ${ONE_TARGET} POST_BUILD 
					COMMAND echo [File Copy]
					COMMAND echo From: "${WIN_ONE_DATA_FILE_LOCATION}\\*"
					COMMAND echo To:   "${WIN_DATA_COPY_DIR}\\."
					COMMAND xcopy "${WIN_ONE_DATA_FILE_LOCATION}\\*" "${WIN_DATA_COPY_DIR}\\." /E /D /C /Y
				)
			else()
				add_custom_command(TARGET ${ONE_TARGET} POST_BUILD 
					COMMAND echo [File Copy]
					COMMAND echo From: "${ONE_DATA_FILE_LOCATION}/*"
					COMMAND echo To:   "${DATA_COPY_DIR}/."
					COMMAND rsync -r "${ONE_DATA_FILE_LOCATION}/*" "${DATA_COPY_DIR}/."
				)
			endif()

			# "cmake -E copy_directory" does the job in any cmake-supporting platforms, but what if the command-line cmake is not installed like MacOSX App?
			#add_custom_command(TARGET ${ONE_TARGET} POST_BUILD 
			#	COMMAND echo Copy
			#	COMMAND echo From: ${ONE_DATA_FILE_LOCATION}
			#	COMMAND echo To:   ${DATA_COPY_DIR}
			#	COMMAND cmake -E copy_directory "${ONE_DATA_FILE_LOCATION}" "${DATA_COPY_DIR}")

		endforeach(ONE_TARGET)
	endforeach(ONE_DATA_FILE_LOCATION)
endif()

#YSEND

#include "ysgldef.h"
#include "ysglslprogram.h"
const char *YSGLSL_variColor3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	if(YSGLSL_TEX_TYPE_NONE==textureType)\n",
	"	{\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_TILING==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_BILLBOARD==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_ATTRIBUTE==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell=texture2D(textureIdent,texCoordOut.xy);\n",
	"		gl_FragColor=gl_FragColor*texcell;\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_3DTILING==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"		texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"		avg=texcell[0]/3.0+texcell[1]/3.0+texcell[2]/3.0;\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"	\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColor3DDrawingFragmentShader_nLine=110;
const char *YSGLSL_variColor3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP   float pointSizeIn;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP   vec4 colorIn;\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"	gl_PointSize=pointSizeIn;\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColor3DDrawingVertexShader_nLine=154;
const char *YSGLSL_variColorPerVtxShading3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	gl_FragColor=colorOut;\n",
	"\n",
	"	if(YSGLSL_TEX_TYPE_NONE==textureType)\n",
	"	{\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_TILING==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_BILLBOARD==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_ATTRIBUTE==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell=texture2D(textureIdent,texCoordOut.xy);\n",
	"		gl_FragColor=gl_FragColor*texcell;\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_3DTILING==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"		texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"		avg=texcell[0]/3.0+texcell[1]/3.0+texcell[2]/3.0;\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"	\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerVtxShading3DDrawingFragmentShader_nLine=110;
const char *YSGLSL_variColorPerVtxShading3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 projection;\n",
	"uniform  HIGHP mat4 modelView;\n",
	"\n",
	"uniform bool lightEnabled[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  HIGHP vec4 lightPos[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  LOWP vec3 lightColor[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  LOWP vec3 specularColor;\n",
	"uniform  MIDP float specularExponent;\n",
	"uniform  LOWP vec3 ambientColor;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  HIGHP  vec3 normal;\n",
	"attribute  LOWP   vec4 color;    // <- Only difference from monoColorPerVtxShader\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	 HIGHP  vec3 nomLocal=normalize((modelView*vec4(normal,0)).xyz);\n",
	"	 HIGHP  vec3 vecToCamera=-normalize(vertexInView.xyz);\n",
	"\n",
	"	// Lighting\n",
	"	//	Input variables: vec4 color\n",
	"	//	                 vec3 nomLocal\n",
	"	//	                 vec3 vecToCamera <- must be normalized\n",
	"	//	Output variable: vec4 accumColor\n",
	"	\n",
	"	 HIGHP  vec3 accumColor;\n",
	"	accumColor=ambientColor*color.xyz;\n",
	"	\n",
	"	for(int lightNo=0; lightNo<YSGLSL_MAX_NUM_LIGHT; lightNo++)\n",
	"	{\n",
	"		if(true==lightEnabled[lightNo])\n",
	"		{\n",
	"			 MIDP  float diffuseIntensity=max(dot(nomLocal,lightPos[lightNo].xyz),0.0);\n",
	"			accumColor+=diffuseIntensity*(color.xyz*lightColor[lightNo]);\n",
	"	\n",
	"			if(0.01<specularColor.r || 0.01<specularColor.g || 0.01<specularColor.b)\n",
	"			{\n",
	"				 HIGHP  vec3 unitVecToCamera=normalize(vecToCamera);\n",
	"				 HIGHP  vec3 mid=normalize(lightPos[lightNo].xyz+unitVecToCamera);\n",
	"				 HIGHP  float specularIntensity=pow(max(dot(mid,nomLocal),0.0),specularExponent);\n",
	"				accumColor+=specularIntensity*specularColor;\n",
	"			}\n",
	"		}\n",
	"	}\n",
	"\n",
	"\n",
	"	colorOut=vec4(accumColor,color[3]);\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerVtxShading3DDrawingVertexShader_nLine=190;
const char *YSGLSL_variColorPerPixShading3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 projection;\n",
	"uniform  HIGHP mat4 modelView;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  HIGHP  vec3 normal;\n",
	"attribute  LOWP   vec4 colorIn;\n",
	"attribute  HIGHP  vec2 texCoord;\n",
	"\n",
	"varying  HIGHP  vec3 normalOut;\n",
	"varying  HIGHP  vec3 vecToCameraOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"uniform LOWP int shadowMapMode;\n",
	"uniform HIGHP mat4 shadowMapTransform;\n",
	"uniform sampler2D shadowMapTexture;\n",
	"\n",
	"varying HIGHP vec4 shadowCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	HIGHP vec4 normal4d=vec4(normal,0);\n",
	"	normalOut=normalize((modelView*normal4d).xyz);\n",
	"	vecToCameraOut=-normalize(vertexInView.xyz);\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"\n",
	"	// Shadow Map >>\n",
	"	if(YSGLSL_SHADOWMAP_NONE==shadowMapMode)\n",
	"	{\n",
	"		shadowCoord=vec4(0,0,0,1);\n",
	"	}\n",
	"	else if(YSGLSL_SHADOWMAP_USE==shadowMapMode ||\n",
	"	        YSGLSL_SHADOWMAP_DEBUG==shadowMapMode)\n",
	"	{\n",
	"		shadowCoord=shadowMapTransform*vec4(vertex,1.0);\n",
	"	}\n",
	"	// Shadow Map <<\n",
	"\n",
	"\n",
	"	//   In orthographic projection, billBoardOffset can simply be calculated by taking XY components of\n",
	"	//   billBoardOffsetInView-modelView*(vec4(billBoardCenter,1.0));\n",
	"	//   However, in perspective projection, a plane perpendicular to the viewing vector must be a reference plane,\n",
	"	//   and therefore heading and pitch angles must be calculated and taken into account.\n",
	"	//   Currently, this GLSL program only supports billboading in perspective projection.\n",
	"	\n",
	"	if(textureType==YSGLSL_TEX_TYPE_BILLBOARD)\n",
	"	{\n",
	"		if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec2 billBoardOffset=(vertexInView-billBoardCenterInView).xy;\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 HIGHP  vec4 billBoardCenterInView=modelView*vec4(billBoardCenter,1.0);\n",
	"			 MIDP  vec3 viewVec=normalize(billBoardCenterInView.xyz);\n",
	"			 MIDP  float pitch=asin(viewVec.y);\n",
	"			 MIDP  float heading=-asin(viewVec.x);\n",
	"			 MIDP  vec3 uVec=vec3(cos(heading),0.0,-sin(heading));\n",
	"			 MIDP  vec3 vVec=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"			 HIGHP  vec3 billBoardOffset3d=(vertexInView-billBoardCenterInView).xyz;\n",
	"			 HIGHP  vec2 billBoardOffset=vec2(dot(billBoardOffset3d,uVec),dot(billBoardOffset3d,vVec));\n",
	"			texCoordOut=vec3(billBoardOffset/billBoardDimension,0.0);\n",
	"		}\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_TILING || textureType==YSGLSL_TEX_TYPE_3DTILING)\n",
	"	{\n",
	"		 LOWP  vec4 texCoordTfm=textureTileTransform*vec4(vertex,1.0);\n",
	"		texCoordOut=texCoordTfm.xyz;\n",
	"		if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"		{\n",
	"			texCoordOut=(texCoordOut+vec3(1.0,1.0,1.0))/vec3(2.0,2.0,2.0);\n",
	"		}\n",
	"	}\n",
	"	else if(textureType==YSGLSL_TEX_TYPE_ATTRIBUTE)\n",
	"	{\n",
	"		texCoordOut=vec3(texCoord,0.0);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		texCoordOut[0]=0.0;\n",
	"		texCoordOut[1]=0.0;\n",
	"		texCoordOut[2]=0.0;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerPixShading3DDrawingVertexShader_nLine=181;
const char *YSGLSL_variColorPerPixShading3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform bool lightEnabled[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  HIGHP vec4 lightPos[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  LOWP vec3 lightColor[YSGLSL_MAX_NUM_LIGHT];\n",
	"uniform  LOWP vec3 specularColor;\n",
	"uniform  MIDP float specularExponent;\n",
	"uniform  LOWP vec3 ambientColor;\n",
	"\n",
	"varying  HIGHP  vec3 normalOut;\n",
	"varying  HIGHP  vec3 vecToCameraOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"\n",
	"LOWP vec4 YsGLSLRainbowColor(HIGHP float t)\n",
	"{\n",
	"	// 0     0.25  0.5    0.75    1\n",
	"	// Blue->Cyan->Green->Yellow->Red\n",
	"\n",
	"	HIGHP float tt;\n",
	"	if(t<0.0)\n",
	"	{\n",
	"		return vec4(0,0,1,1);\n",
	"	}\n",
	"	else if(t<0.25)\n",
	"	{\n",
	"		tt=t/0.25;\n",
	"		return vec4(0,tt,1,1);\n",
	"	}\n",
	"	else if(t<0.5)\n",
	"	{\n",
	"		tt=(t-0.25)/0.25;\n",
	"		return vec4(0,1,1.0-tt,1);\n",
	"	}\n",
	"	else if(t<0.75)\n",
	"	{\n",
	"		tt=(t-0.5)/0.25;\n",
	"		return vec4(tt,1,0,1);\n",
	"	}\n",
	"	else if(t<1.0)\n",
	"	{\n",
	"		tt=(t-0.75)/0.25;\n",
	"		return vec4(1,1.0-tt,0,1);\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		return vec4(1,0,0,1);\n",
	"	}\n",
	"}\n",
	"\n",
	"\n",
	"\n",
	"// Variables for texturing\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  mat4 textureTileTransform;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform  HIGHP  vec3 billBoardCenter;\n",
	"uniform  HIGHP  vec2 billBoardDimension;\n",
	"uniform sampler2D textureIdent;\n",
	"varying  HIGHP  vec3 texCoordOut;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"uniform LOWP int shadowMapMode;\n",
	"uniform HIGHP mat4 shadowMapTransform;\n",
	"uniform sampler2D shadowMapTexture;\n",
	"\n",
	"varying HIGHP vec4 shadowCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP vec3 nomLocal=normalize(normalOut);\n",
	"	 HIGHP vec3 vecToCamera=normalize(vecToCameraOut);\n",
	"\n",
	"	// Lighting\n",
	"	//	Input variables: vec4 color\n",
	"	//	                 vec3 nomLocal\n",
	"	//	                 vec3 vecToCamera <- must be normalized\n",
	"	//	Output variable: vec4 accumColor\n",
	"	\n",
	"	 HIGHP  vec3 accumColor;\n",
	"	accumColor=ambientColor*color.xyz;\n",
	"	\n",
	"	for(int lightNo=0; lightNo<YSGLSL_MAX_NUM_LIGHT; lightNo++)\n",
	"	{\n",
	"		if(true==lightEnabled[lightNo])\n",
	"		{\n",
	"			 MIDP  float diffuseIntensity=max(dot(nomLocal,lightPos[lightNo].xyz),0.0);\n",
	"			accumColor+=diffuseIntensity*(color.xyz*lightColor[lightNo]);\n",
	"	\n",
	"			if(0.01<specularColor.r || 0.01<specularColor.g || 0.01<specularColor.b)\n",
	"			{\n",
	"				 HIGHP  vec3 unitVecToCamera=normalize(vecToCamera);\n",
	"				 HIGHP  vec3 mid=normalize(lightPos[lightNo].xyz+unitVecToCamera);\n",
	"				 HIGHP  float specularIntensity=pow(max(dot(mid,nomLocal),0.0),specularExponent);\n",
	"				accumColor+=specularIntensity*specularColor;\n",
	"			}\n",
	"		}\n",
	"	}\n",
	"\n",
	"\n",
	"	gl_FragColor=vec4(accumColor,color[3]);\n",
	"\n",
	"\n",
	"	// Shadow Map (Tentative) >>\n",
	"	if(YSGLSL_SHADOWMAP_NONE==shadowMapMode)\n",
	"	{\n",
	"	}\n",
	"	else if(YSGLSL_SHADOWMAP_USE==shadowMapMode ||\n",
	"	        YSGLSL_SHADOWMAP_DEBUG==shadowMapMode)\n",
	"	{\n",
	"		HIGHP vec3 shadowCoordTfm=shadowCoord.xyz/shadowCoord.w;\n",
	"		shadowCoordTfm=(shadowCoordTfm+vec3(1,1,1))/2.0;\n",
	"		if(0.0<shadowCoordTfm.x && shadowCoordTfm.x<1.0 &&\n",
	"		   0.0<shadowCoordTfm.y && shadowCoordTfm.y<1.0)\n",
	"		{\n",
	"			HIGHP float depth;\n",
	"			depth=texture2D(shadowMapTexture,shadowCoordTfm.xy).r;\n",
	"			gl_FragColor=YsGLSLRainbowColor(depth);\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			gl_FragColor=vec4(1,0,1,1);\n",
	"		}\n",
	"	}\n",
	"	// Shadow Map (Tentative) <<\n",
	"\n",
	"\n",
	"	if(YSGLSL_TEX_TYPE_NONE==textureType)\n",
	"	{\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_TILING==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_BILLBOARD==textureType ||\n",
	"	        YSGLSL_TEX_TYPE_ATTRIBUTE==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell=texture2D(textureIdent,texCoordOut.xy);\n",
	"		gl_FragColor=gl_FragColor*texcell;\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_3DTILING==textureType)\n",
	"	{\n",
	"		 LOWP  vec4 texcell[3],avg;\n",
	"		texcell[0]=texture2D(textureIdent,texCoordOut.xy);\n",
	"		texcell[1]=texture2D(textureIdent,texCoordOut.xz);\n",
	"		texcell[2]=texture2D(textureIdent,texCoordOut.yz);\n",
	"		avg=texcell[0]/3.0+texcell[1]/3.0+texcell[2]/3.0;\n",
	"		gl_FragColor=gl_FragColor*avg;\n",
	"	}\n",
	"	\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPerPixShading3DDrawingFragmentShader_nLine=220;
const char *YSGLSL_variColorBillBoard3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform int pointClippingType;\n",
	"uniform int billBoardTransformType;\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"varying  HIGHP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	if(YSGLSL_BILLBOARD_CLIPPING_CIRCLE==pointClippingType)\n",
	"	{\n",
	"		 MIDP  vec2 nomLocal=(texCoordOut.xy*2.0)-vec2(1.0,1.0);\n",
	"		if(1.0<=dot(nomLocal,nomLocal))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"\n",
	"	 LOWP  vec4 texcell=texture2D(textureIdent,texCoordOut);\n",
	"	gl_FragColor=color*texcell;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorBillBoard3DDrawingFragmentShader_nLine=94;
const char *YSGLSL_variColorBillBoard3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform int billBoardTransformType;\n",
	"uniform bool useNegativeOneToPositiveOneTexCoord;\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  MIDP  vec3 viewOffset;\n",
	"attribute  MIDP  vec2 texCoord;\n",
	"\n",
	"varying  HIGHP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	if(YSGLSL_TEX_BILLBOARD_ORTHO==billBoardTransformType)\n",
	"	{\n",
	"		vertexInView.xyz+=viewOffset;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		vec3 axis[3];\n",
	"		 MIDP  vec3 viewVec=normalize(vertexInView.xyz);\n",
	"		 MIDP  float pitch=asin(viewVec.y);\n",
	"		 MIDP  float heading=-asin(viewVec.x);\n",
	"		axis[0]=vec3(cos(heading),0.0,-sin(heading));\n",
	"		axis[1]=vec3(-sin(pitch)*sin(heading),cos(pitch),sin(pitch)*cos(heading));\n",
	"		axis[2]=-viewVec;\n",
	"		vertexInView.xyz+=(axis[0]*viewOffset[0]+axis[1]*viewOffset[1]+axis[2]*viewOffset[2]);\n",
	"	}\n",
	"	texCoordOut=texCoord;\n",
	"	if(true==useNegativeOneToPositiveOneTexCoord)\n",
	"	{\n",
	"		texCoordOut=(texCoordOut+vec2(1.0,1.0))/vec2(2.0,2.0);\n",
	"	}\n",
	"	color=colorIn;\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorBillBoard3DDrawingVertexShader_nLine=116;
const char *YSGLSL_flash3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"varying  LOWP  vec2 uv;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// No alpha cut off in the flash renderer.\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	const  MIDP  float PI=3.1415927;\n",
	"	const  MIDP  float halfPI=3.1415927/2.0;\n",
	"	const  MIDP  float twoPI=3.1415927*2.0;\n",
	"	 MIDP  float r=length(uv);\n",
	"	if(r<=radius1)\n",
	"	{\n",
	"		 MIDP  float param=halfPI*(radius1-r)/radius1;\n",
	"		 MIDP  float additive=sin(param)*maxIntensity;\n",
	"		gl_FragColor[0]=min(1.0,color[0]+additive);\n",
	"		gl_FragColor[1]=min(1.0,color[1]+additive);\n",
	"		gl_FragColor[2]=min(1.0,color[2]+additive);\n",
	"		gl_FragColor[3]=color[3];\n",
	"\n",
	"		if(false!=fogEnabled)\n",
	"		{\n",
	"			 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"			 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"			 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"			gl_FragColor[0]=fogMix[0];\n",
	"			gl_FragColor[1]=fogMix[1];\n",
	"			gl_FragColor[2]=fogMix[2];\n",
	"		}\n",
	"\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		 MIDP  float halfInterval=angleInterval/2.0;\n",
	"		 MIDP  float theata=twoPI+angleOffset+atan(uv.y,uv.x);\n",
	"		 MIDP  float t=mod(theata,angleInterval);\n",
	"		 MIDP  float s=1.0-abs(t-halfInterval)/halfInterval;\n",
	"\n",
	"		 MIDP  float rf=radius1+(radius2-radius1)*pow(s,exponent);\n",
	"		if(rf<r)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			 MIDP  float alpha=max(1.0-(r-radius1)/(rf-radius1),0.0);\n",
	"			gl_FragColor[0]=color[0];\n",
	"			gl_FragColor[1]=color[1];\n",
	"			gl_FragColor[2]=color[2];\n",
	"			gl_FragColor[3]=color[3]*alpha;\n",
	"\n",
	"			if(false!=fogEnabled)\n",
	"			{\n",
	"				 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"				 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"				 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"				gl_FragColor[0]=fogMix[0];\n",
	"				gl_FragColor[1]=fogMix[1];\n",
	"				gl_FragColor[2]=fogMix[2];\n",
	"			}\n",
	"\n",
	"		}\n",
	"    }\n",
	"}\n",
};
const int YSGLSL_flash3DDrawingFragmentShader_nLine=124;
const char *YSGLSL_flash3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float dimension;\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  HIGHP  vec3 viewOffset;\n",
	"\n",
	"varying  LOWP  vec2 uv;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	vec3 offset=viewOffset*dimension;\n",
	"	vertexInView.x+=offset.x;\n",
	"	vertexInView.y+=offset.y;\n",
	"	vertexInView.z+=offset.z;\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	uv=vec2(viewOffset.x,viewOffset.y);\n",
	"	color=colorIn;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_flash3DDrawingVertexShader_nLine=106;
const char *YSGLSL_flashByPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// No alpha cut off in the flash renderer.\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP vec2 uv=((gl_PointCoord.xy*2.0)-vec2(1.0,1.0));\n",
	"\n",
	"	const  MIDP  float PI=3.1415927;\n",
	"	const  MIDP  float halfPI=3.1415927/2.0;\n",
	"	const  MIDP  float twoPI=3.1415927*2.0;\n",
	"	 MIDP  float r=length(uv);\n",
	"	if(r<=radius1)\n",
	"	{\n",
	"		 MIDP  float param=halfPI*(radius1-r)/radius1;\n",
	"		 MIDP  float additive=sin(param)*maxIntensity;\n",
	"		gl_FragColor[0]=min(1.0,color[0]+additive);\n",
	"		gl_FragColor[1]=min(1.0,color[1]+additive);\n",
	"		gl_FragColor[2]=min(1.0,color[2]+additive);\n",
	"		gl_FragColor[3]=color[3];\n",
	"\n",
	"		if(false!=fogEnabled)\n",
	"		{\n",
	"			 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"			 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"			 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"			gl_FragColor[0]=fogMix[0];\n",
	"			gl_FragColor[1]=fogMix[1];\n",
	"			gl_FragColor[2]=fogMix[2];\n",
	"		}\n",
	"\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		 MIDP  float halfInterval=angleInterval/2.0;\n",
	"		 MIDP  float theata=twoPI+angleOffset+atan(uv.y,uv.x);\n",
	"		 MIDP  float t=mod(theata,angleInterval);\n",
	"		 MIDP  float s=1.0-abs(t-halfInterval)/halfInterval;\n",
	"\n",
	"		 MIDP  float rf=radius1+(radius2-radius1)*pow(s,exponent);\n",
	"		if(rf<r)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			MIDP  float alpha=max(1.0-(r-radius1)/(rf-radius1),0.0);\n",
	"			gl_FragColor[0]=color[0];\n",
	"			gl_FragColor[1]=color[1];\n",
	"			gl_FragColor[2]=color[2];\n",
	"			gl_FragColor[3]=color[3]*alpha;\n",
	"\n",
	"			if(false!=fogEnabled)\n",
	"			{\n",
	"				 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"				 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"				 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"				gl_FragColor[0]=fogMix[0];\n",
	"				gl_FragColor[1]=fogMix[1];\n",
	"				gl_FragColor[2]=fogMix[2];\n",
	"			}\n",
	"\n",
	"		}\n",
	"    }\n",
	"}\n",
};
const int YSGLSL_flashByPointSprite3DDrawingFragmentShader_nLine=125;
const char *YSGLSL_flashByPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float dimension;\n",
	"uniform  MIDP  float radius1;\n",
	"uniform  MIDP  float radius2;\n",
	"uniform  MIDP  float maxIntensity;\n",
	"uniform  MIDP  float angleInterval;\n",
	"uniform  MIDP  float angleOffset;\n",
	"uniform  MIDP  float exponent;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"\n",
	"attribute  HIGHP vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  MIDP  float pointSizeIn;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform int pointSizeMode;\n",
	"uniform int pointClippingType;\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void Ys_ProcessPointSprite()\n",
	"{\n",
	"	if(pointSizeMode==YSGLSL_POINTSPRITE_SIZE_IN_PIXEL)\n",
	"	{\n",
	"		gl_PointSize=pointSizeIn;\n",
	"	}\n",
	"	else if(pointSizeMode==YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE)\n",
	"	{\n",
	"		HIGHP vec4 prj1=projection*modelView*vec4(vertex,1.0);\n",
	"		HIGHP vec4 prj2=modelView*vec4(vertex,1.0);\n",
	"		prj2.y+=pointSizeIn;\n",
	"		prj2=projection*prj2;\n",
	"		gl_PointSize=viewportHei*abs(prj2[1]/prj2[3]-prj1[1]/prj1[3])/2.0;\n",
	"	}\n",
	"}\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"\n",
	"	Ys_ProcessPointSprite();\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_flashByPointSprite3DDrawingVertexShader_nLine=127;
const char *YSGLSL_variColorMarker3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform int markerType;\n",
	"uniform  MIDP  float dimension;\n",
	"\n",
	"varying  MIDP  vec2 offsetOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	if(markerType==YSGLSL_MARKER_TYPE_RECT)\n",
	"	{\n",
	"		if(dimension<abs(offsetOut.x) || dimension<abs(offsetOut.y))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_CIRCLE)\n",
	"	{\n",
	"		if(dimension*dimension<offsetOut.x*offsetOut.x+offsetOut.y*offsetOut.y)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_RECT)\n",
	"	{\n",
	"		if( dimension    <abs(offsetOut.x) || dimension    <abs(offsetOut.y) ||\n",
	"		   (dimension-1.2>abs(offsetOut.x) && dimension-1.2>abs(offsetOut.y)))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_CIRCLE)\n",
	"	{\n",
	"		 MIDP  float offsetSq=offsetOut.x*offsetOut.x+offsetOut.y*offsetOut.y;\n",
	"		if( dimension*dimension           <offsetSq ||\n",
	"		   (dimension-1.2)*(dimension-1.2)>offsetSq)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_STAR)\n",
	"	{\n",
	"		// See star.png for the equations.\n",
	"		bool show=false;\n",
	"		MIDP  float  x=offsetOut.x/dimension;\n",
	"		MIDP  float  y=offsetOut.y/dimension;\n",
	"		MIDP  float  x3_077685=3.0077685*x;\n",
	"		MIDP  float  yMinus1=y-1.0;\n",
	"		if(y<=0.309017)\n",
	"		{\n",
	"			MIDP  float  x0_726543=0.726543*x;\n",
	"			MIDP  float  yPlus0_381966=y+0.381966;\n",
	"			if((yPlus0_381966>= x0_726543 && yMinus1<= x3_077685) ||\n",
	"			   (yPlus0_381966>=-x0_726543 && yMinus1<=-x3_077685))\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			if(yMinus1<=x3_077685 && yMinus1<=-x3_077685)\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_STAR)\n",
	"	{\n",
	"		bool show=false;\n",
	"		MIDP  float  x=offsetOut.x/dimension;\n",
	"		MIDP  float  y=offsetOut.y/dimension;\n",
	"		MIDP  float  q1=-3.077685*x+1.0;\n",
	"		MIDP  float  q2= 3.077685*x+1.0;\n",
	"		MIDP  float  q3= 0.726543*x-0.381966;\n",
	"		MIDP  float  q4=-0.726543*x-0.381966;\n",
	"		if(y>=0.309017 && y<=q1 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q1 && y>=q3)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q2 && y>=q4)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q3 && y>=q4 && y<=q1)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q4 && y>=q3 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorMarker3DDrawingFragmentShader_nLine=178;
const char *YSGLSL_variColorMarker3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"uniform int viewportOrigin;\n",
	"\n",
	"uniform int markerType;\n",
	"uniform  MIDP  float dimension;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  MIDP  vec2 pixelOffset;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"\n",
	"varying  MIDP  vec2 offsetOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"	float xOffset=((2.0*pixelOffset.x)/viewportWid)*gl_Position[3];\n",
	"	float yOffset=((2.0*pixelOffset.y)/viewportHei)*gl_Position[3];\n",
	"	gl_Position.x+=xOffset;\n",
	"	gl_Position.y+=yOffset;\n",
	"	offsetOut=pixelOffset;\n",
	"	color=colorIn;\n",
	"}\n",
};
const int YSGLSL_variColorMarker3DDrawingVertexShader_nLine=100;
const char *YSGLSL_variColorMarkerByPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"\n",
	"uniform int markerType;\n",
	"uniform MIDP float dimension;\n",
	"\n",
	"varying LOWP vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	MIDP vec2 t=(gl_PointCoord.xy*2.0)-vec2(1.0,1.0);\n",
	"	t.y=-t.y;\n",
	"\n",
	"	if(markerType==YSGLSL_MARKER_TYPE_RECT)\n",
	"	{\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_CIRCLE)\n",
	"	{\n",
	"		if(1.0<dot(t,t))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_RECT)\n",
	"	{\n",
	"		MIDP float frameSize=2.4/dimension; // 1pixel=2.0/dimension   1.2pixel=2.4/dimension\n",
	"		if(abs(t.x)<1.0-frameSize && abs(t.y)<1.0-frameSize)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_CIRCLE)\n",
	"	{\n",
	"		MIDP float frameSize=2.4/dimension; // 1pixel=2.0/dimension   1.2pixel=2.4/dimension\n",
	"		MIDP float tsq=dot(t,t);\n",
	"		MIDP float inRad=1.0-frameSize;\n",
	"		if(tsq<inRad*inRad || 1.0<tsq)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_STAR)\n",
	"	{\n",
	"		// See star.png for the equations.\n",
	"		bool show=false;\n",
	"		MIDP  float  x=t.x;\n",
	"		MIDP  float  y=t.y;\n",
	"		MIDP  float  x3_077685=3.0077685*x;\n",
	"		MIDP  float  yMinus1=y-1.0;\n",
	"		if(y<=0.309017)\n",
	"		{\n",
	"			MIDP float x0_726543=0.726543*x;\n",
	"			MIDP float yPlus0_381966=y+0.381966;\n",
	"			if((yPlus0_381966>= x0_726543 && yMinus1<= x3_077685) ||\n",
	"			   (yPlus0_381966>=-x0_726543 && yMinus1<=-x3_077685))\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		else\n",
	"		{\n",
	"			if(yMinus1<=x3_077685 && yMinus1<=-x3_077685)\n",
	"			{\n",
	"				show=true;\n",
	"			}\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	else if(markerType==YSGLSL_MARKER_TYPE_EMPTY_STAR)\n",
	"	{\n",
	"		bool show=false;\n",
	"		MIDP  float  x=t.x;\n",
	"		MIDP  float  y=t.y;\n",
	"		MIDP  float  q1=-3.077685*x+1.0;\n",
	"		MIDP  float  q2= 3.077685*x+1.0;\n",
	"		MIDP  float  q3= 0.726543*x-0.381966;\n",
	"		MIDP  float  q4=-0.726543*x-0.381966;\n",
	"		if(y>=0.309017 && y<=q1 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q1 && y>=q3)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=0.309017 && y>=q2 && y>=q4)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q3 && y>=q4 && y<=q1)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		else if(y<=q4 && y>=q3 && y<=q2)\n",
	"		{\n",
	"			show=true;\n",
	"		}\n",
	"		if(true!=show)\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"	gl_FragColor=color;\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorMarkerByPointSprite3DDrawingFragmentShader_nLine=180;
const char *YSGLSL_variColorMarkerByPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"\n",
	"uniform int markerType;\n",
	"uniform MIDP float dimension;\n",
	"\n",
	"attribute HIGHP vec3 vertex;\n",
	"attribute LOWP vec4 colorIn;\n",
	"\n",
	"varying LOWP vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"\n",
	"	color=colorIn;\n",
	"\n",
	"	gl_PointSize=dimension;\n",
	"}\n",
};
const int YSGLSL_variColorMarkerByPointSprite3DDrawingVertexShader_nLine=94;
const char *YSGLSL_bmpRendererVertexShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"// offset is taken as pixels if transformationType is true, or size in 3D space.\n",
	"// transformationType:\n",
	"//    0: Attributes vertex and offset are both taken as in 3D coordinate.\n",
	"//    1: Attributes vertex and offset are both taken as in window coordinate.\n",
	"//    2: Attribute vertex is taken as in 3D coordinate, and offset is taken as in window coordinate\n",
	"uniform  HIGHP  mat4 projection,modelView;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"uniform sampler2D texture;\n",
	"uniform int transformationType;\n",
	"uniform int viewportOrigin;\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"attribute  HIGHP  vec4 vertex;\n",
	"attribute  MIDP  vec2 offset;\n",
	"attribute  MIDP vec2 texCoord;\n",
	"\n",
	"varying  MIDP  vec2 texCoord_out;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	texCoord_out=texCoord;\n",
	"	if(1==transformationType)\n",
	"	{\n",
	"		float xOffset=(2.0*offset.x)/viewportWid;\n",
	"		float yOffset=(2.0*offset.y)/viewportHei;\n",
	"\n",
	"		float xAbs=-1.0+2.0*vertex.x/viewportWid+xOffset;\n",
	"		float yAbs= 1.0-2.0*vertex.y/viewportHei;\n",
	"		if(0!=viewportOrigin)\n",
	"		{\n",
	"			yAbs=-yAbs;\n",
	"		}\n",
	"		yAbs+=yOffset;\n",
	"		gl_Position=vec4(xAbs,yAbs,0.0,1.0);\n",
	"	}\n",
	"	else if(0==transformationType)\n",
	"	{\n",
	"		vec4 inCameraCoord=modelView*vertex+vec4(offset.x,offset.y,0,0);\n",
	"		gl_Position=projection*inCameraCoord;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		float xOffset=(2.0*offset.x)/viewportWid;\n",
	"		float yOffset=(2.0*offset.y)/viewportHei;\n",
	"		gl_Position=projection*modelView*vertex;\n",
	"		gl_Position.x+=xOffset;\n",
	"		gl_Position.y+=yOffset;\n",
	"	}\n",
	"}\n",
};
const int YSGLSL_bmpRendererVertexShaderSrc_nLine=96;
const char *YSGLSL_bmpRendererFragmentShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform sampler2D texture;\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"varying  MIDP  vec2 texCoord_out;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 LOWP  vec4 texcell=texture2D(texture,texCoord_out);\n",
	"	if(alphaCutOff<texcell.a)\n",
	"	{\n",
	"		gl_FragColor=texcell;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"}\n",
};
const int YSGLSL_bmpRendererFragmentShaderSrc_nLine=64;
const char *YSGLSL_plain2DDrawingVertexShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4 transform;\n",
	"\n",
	"attribute  LOWP  vec2 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	vec4 vertex4d=vec4(vertex,0,1);\n",
	"	gl_Position=transform*vertex4d;\n",
	"	colorOut=colorIn;\n",
	"}\n",
};
const int YSGLSL_plain2DDrawingVertexShaderSrc_nLine=60;
const char *YSGLSL_plain2DDrawingFragmentShaderSrc[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP mat4 transform;\n",
	"\n",
	"varying  LOWP  vec4 colorOut;\n",
	"\n",
	"void main()\n",
	"{\n",
	"	gl_FragColor=colorOut;\n",
	"}\n",
};
const int YSGLSL_plain2DDrawingFragmentShaderSrc_nLine=55;
const char *YSGLSL_variColorPointSprite3DDrawingFragmentShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform sampler2D textureIdent;\n",
	"\n",
	"varying  MIDP  vec2 texCoordOut;\n",
	"varying  LOWP  vec4 color;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for alpha cutoff\n",
	"uniform  LOWP  float alphaCutOff;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform int pointSizeMode;\n",
	"uniform int pointClippingType;\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	if(YSGLSL_POINTSPRITE_CLIPPING_CIRCLE==pointClippingType)\n",
	"	{\n",
	"		 MIDP  vec2 t=(gl_PointCoord.xy*2.0)-vec2(1.0,1.0);\n",
	"		if(1.0<=dot(t,t))\n",
	"		{\n",
	"			discard;\n",
	"		}\n",
	"	}\n",
	"\n",
	"	if(YSGLSL_TEX_TYPE_TILING==textureType ||\n",
	"	   YSGLSL_TEX_TYPE_BILLBOARD==textureType)\n",
	"	{\n",
	"		 MIDP  vec2 texCoord=texCoordOut+gl_PointCoord*texCoordRange;\n",
	"		 LOWP  vec4 texcell=texture2D(textureIdent,texCoord);\n",
	"		gl_FragColor=color*texcell;\n",
	"	}\n",
	"	else if(YSGLSL_TEX_TYPE_NONE==textureType)\n",
	"	{\n",
	"		gl_FragColor=color;\n",
	"	}\n",
	"    else\n",
	"    {\n",
	"        gl_FragColor=vec4(0,0,0,1);\n",
	"    }\n",
	"\n",
	"	// gl_FragColor.rg=gl_PointCoord;  For debugging.\n",
	"\n",
	"	if(gl_FragColor.a<alphaCutOff)\n",
	"	{\n",
	"		discard;\n",
	"	}\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		 MIDP  float d=fogDensity*abs(zInViewCoord);\n",
	"		 MIDP  float f=clamp(exp(-d*d),0.0,1.0);\n",
	"		 LOWP  vec3 fogMix=mix(fogColor.rgb,gl_FragColor.rgb,f);\n",
	"		gl_FragColor[0]=fogMix[0];\n",
	"		gl_FragColor[1]=fogMix[1];\n",
	"		gl_FragColor[2]=fogMix[2];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPointSprite3DDrawingFragmentShader_nLine=115;
const char *YSGLSL_variColorPointSprite3DDrawingVertexShader[]=
{
	"#define YSGLSL_TEX_TYPE_NONE                0\n",
	"#define YSGLSL_TEX_TYPE_TILING              1\n",
	"#define YSGLSL_TEX_TYPE_BILLBOARD           2\n",
	"#define YSGLSL_TEX_TYPE_3DTILING            3\n",
	"#define YSGLSL_TEX_TYPE_ATTRIBUTE           4\n",
	"#define YSGLSL_TEX_BILLBOARD_PERS           0\n",
	"#define YSGLSL_TEX_BILLBOARD_ORTHO          1\n",
	"#define YSGLSL_TEX_WRAP_CUTOFF              0\n",
	"#define YSGLSL_TEX_WRAP_REPEAT              1\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_NONE      0\n",
	"#define YSGLSL_BILLBOARD_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_NONE      0\n",
	"#define YSGLSL_POINTSPRITE_CLIPPING_CIRCLE    1\n",
	"#define YSGLSL_MARKER_TYPE_PLAIN            0\n",
	"#define YSGLSL_MARKER_TYPE_CIRCLE           1\n",
	"#define YSGLSL_MARKER_TYPE_RECT             2\n",
	"#define YSGLSL_MARKER_TYPE_STAR             3\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_RECT       4\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_CIRCLE     5\n",
	"#define YSGLSL_MARKER_TYPE_EMPTY_STAR       6\n",
	"#define YSGLSL_MAX_NUM_LIGHT                8\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_PIXEL    0\n",
	"#define YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE  1\n",
	"#define YSGLSL_RENDERER_TYPE_NONE           0\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN2D        1\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER2D       2\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE2D  3\n",
	"#define YSGLSL_RENDERER_TYPE_PLAIN3D        10\n",
	"#define YSGLSL_RENDERER_TYPE_SHADED3D       11\n",
	"#define YSGLSL_RENDERER_TYPE_FLASH          12\n",
	"#define YSGLSL_RENDERER_TYPE_MARKER3D       13\n",
	"#define YSGLSL_RENDERER_TYPE_POINTSPRITE3D  14\n",
	"#define YSGLSL_SHADOWMAP_NONE               0\n",
	"#define YSGLSL_SHADOWMAP_USE                1\n",
	"#define YSGLSL_SHADOWMAP_DEBUG              2\n",
	"\n",
	"#ifdef GL_ES\n",
	"	#define LOWP lowp\n",
	"	#define MIDP mediump\n",
	"	#define HIGHP highp\n",
	"#else\n",
	"	#define LOWP\n",
	"	#define MIDP\n",
	"	#define HIGHP\n",
	"#endif\n",
	"\n",
	"\n",
	"uniform  HIGHP  mat4  projection;\n",
	"uniform  HIGHP  mat4  modelView;\n",
	"uniform sampler2D textureIdent;\n",
	"uniform  MIDP  float viewportWid,viewportHei;\n",
	"\n",
	"attribute  HIGHP  vec3 vertex;\n",
	"attribute  LOWP  vec4 colorIn;\n",
	"attribute  LOWP  vec2 texCoordIn;\n",
	"attribute  MIDP  float pointSizeIn;\n",
	"\n",
	"varying  LOWP  vec4 color;\n",
	"varying  MIDP  vec2 texCoordOut;\n",
	"\n",
	"// Variables for fog\n",
	"uniform bool fogEnabled;\n",
	"uniform  MIDP  float fogDensity;\n",
	"uniform  LOWP  vec4 fogColor;\n",
	"varying  HIGHP  float zInViewCoord;\n",
	"\n",
	"// Variables for z-offset\n",
	"uniform bool useZOffset;\n",
	"uniform  MIDP  float zOffset;\n",
	"\n",
	"// Variables for POINT_SPRITE\n",
	"uniform int pointSizeMode;\n",
	"uniform int pointClippingType;\n",
	"uniform  LOWP  int textureType;\n",
	"uniform  LOWP  float texCoordRange;\n",
	"\n",
	"\n",
	"\n",
	"\n",
	"void Ys_ProcessPointSprite()\n",
	"{\n",
	"	if(pointSizeMode==YSGLSL_POINTSPRITE_SIZE_IN_PIXEL)\n",
	"	{\n",
	"		gl_PointSize=pointSizeIn;\n",
	"	}\n",
	"	else if(pointSizeMode==YSGLSL_POINTSPRITE_SIZE_IN_3DSPACE)\n",
	"	{\n",
	"		HIGHP vec4 prj1=projection*modelView*vec4(vertex,1.0);\n",
	"		HIGHP vec4 prj2=modelView*vec4(vertex,1.0);\n",
	"		prj2.y+=pointSizeIn;\n",
	"		prj2=projection*prj2;\n",
	"		gl_PointSize=viewportHei*abs(prj2[1]/prj2[3]-prj1[1]/prj1[3])/2.0;\n",
	"	}\n",
	"}\n",
	"\n",
	"\n",
	"void main()\n",
	"{\n",
	"	 HIGHP  vec4 vertexInView=modelView*vec4(vertex,1.0);\n",
	"\n",
	"	texCoordOut=texCoordIn;\n",
	"	color=colorIn;\n",
	"\n",
	"	Ys_ProcessPointSprite();\n",
	"\n",
	"	if(false!=fogEnabled)\n",
	"	{\n",
	"		zInViewCoord=-vertexInView.z;\n",
	"	}\n",
	"	else\n",
	"	{\n",
	"		zInViewCoord=0.0;\n",
	"	}\n",
	"\n",
	"	gl_Position=projection*vertexInView;\n",
	"\n",
	"	if(true==useZOffset)\n",
	"	{\n",
	"		gl_Position.z+=zOffset*gl_Position[3];\n",
	"	}\n",
	"\n",
	"}\n",
};
const int YSGLSL_variColorPointSprite3DDrawingVertexShader_nLine=122;
